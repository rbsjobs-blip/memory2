<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sentence Match Memory Game</title>
    <style>
        /* --- Basic Page Styles --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: #f0f4f8;
            color: #333;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Espaçamento geral entre os elementos */
            width: 100%;
            max-width: 820px;
        }

        h1 {
            color: #005a9c;
            text-align: center;
            margin-bottom: 5px; /* Pequena margem inferior */
        }

        /* --- Tela de seleção de modo --- */
        #mode-selection {
            text-align: center;
        }

        .mode-button {
            padding: 15px 30px; font-size: 1.2em; margin: 10px; cursor: pointer;
            border: 2px solid #007bff; background-color: #fff; color: #007bff;
            border-radius: 8px; font-weight: bold; transition: all 0.3s ease;
        }
        .mode-button:hover { background-color: #007bff; color: #fff; }

        /* Jogo fica escondido por padrão */
        #game-container {
            display: none; 
        }

        /* --- Contêiner para os botões de ação --- */
        #action-buttons {
            display: flex;
            justify-content: center;
            gap: 15px; /* Espaço entre os botões */
            width: 100%;
        }

        /* --- Game Info --- */
        #game-info {
            display: flex; justify-content: space-around; width: 100%;
            background-color: #fff; padding: 15px; border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); font-size: 1.2em;
        }
        .score-panel, #turn-indicator, #moves-counter { display: none; }
        .player.active { color: #d9534f; transform: scale(1.1); transition: all 0.3s ease; }

        /* --- Game Board --- */
        #game-board {
            display: grid; grid-template-columns: repeat(6, 1fr);
            gap: 10px; width: 100%; perspective: 1000px;
        }

        .card {
            background-color: transparent; height: 100px; border-radius: 10px;
            cursor: pointer; position: relative; transform-style: preserve-3d;
            transition: transform 0.6s; border: none; padding: 0; font-family: inherit;
        }
        .card.flipped { transform: rotateY(180deg); }

        .card-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden; border-radius: 10px;
            display: flex; justify-content: center; align-items: center;
            text-align: center; padding: 10px; box-sizing: border-box;
            font-size: 0.9em;
        }
        .card-front { background-color: #007bff; color: white; font-size: 2em; font-weight: bold; }
        .card-back { background-color: #e9ecef; color: #343a40; transform: rotateY(180deg); border: 2px solid #007bff; }
        .card.matched { transform: rotateY(180deg); cursor: default; }
        .card.matched .card-back { background-color: #d4edda; border-color: #28a745; }
        #game-board.locked .card:not(.matched) { pointer-events: none; }

        /* --- Botões de Ação --- */
        .action-button {
            padding: 10px 20px; font-size: 1em; font-weight: bold;
            color: #fff; border: none; border-radius: 5px; cursor: pointer;
            transition: background-color 0.3s, opacity 0.3s;
        }
        #reset-button { background-color: #dc3545; }
        #reset-button:hover { background-color: #c82333; }

        #peek-button { background-color: #ffc107; color: #212529; }
        #peek-button:hover { background-color: #e0a800; }
        #peek-button:disabled { background-color: #6c757d; opacity: 0.6; cursor: not-allowed; }

        /* Responsive */
        @media (max-width: 820px) { #game-board { grid-template-columns: repeat(4, 1fr); } }
        @media (max-width: 600px) {
            #game-board { grid-template-columns: repeat(3, 1fr); }
            .card-face { font-size: 0.8em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Tela de seleção de modo -->
        <div id="mode-selection">
            <h1>Sentence Matching Memory Game</h1>
            <h2>Select a Game Mode</h2>
            <button id="single-player-btn" class="mode-button">Single Player</button>
            <button id="two-player-btn" class="mode-button">Two Players</button>
        </div>

        <!-- Container do Jogo -->
        <div id="game-container" class="container">
            <h1>Sentence Matching Game</h1>

            <div id="action-buttons">
                <button id="peek-button" class="action-button">Peek Cards (1 use)</button>
                <button id="reset-button" class="action-button">Change Mode</button>
            </div>

            <div id="game-info">
                <div id="player1-score" class="score-panel player">Player 1: 0</div>
                <div id="turn-indicator">Player 1's Turn</div>
                <div id="player2-score" class="score-panel player">Player 2: 0</div>
                <div id="moves-counter" style="font-weight: bold;">Moves: 0</div>
            </div>

            <div id="game-board"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const modeSelection = document.getElementById('mode-selection');
        const gameContainer = document.getElementById('game-container');
        const singlePlayerBtn = document.getElementById('single-player-btn');
        const twoPlayerBtn = document.getElementById('two-player-btn');
        const gameBoard = document.getElementById('game-board');
        const resetButton = document.getElementById('reset-button');
        const peekButton = document.getElementById('peek-button');

        const p1ScoreElem = document.getElementById('player1-score');
        const p2ScoreElem = document.getElementById('player2-score');
        const turnIndicator = document.getElementById('turn-indicator');
        const movesCounter = document.getElementById('moves-counter');

        const FLIP_DELAY = 1200;
        const PEEK_DURATION = 5000;

        const sentenceParts = [
            { text: 'She works', id: 1 }, { text: 'at a technology company.', id: 1 },
            { text: 'They play soccer', id: 2 }, { text: 'in the park every Sunday.', id: 2 },
            { text: "He doesn't like", id: 3 }, { text: 'to wake up early.', id: 3 },
            { text: "We don't watch", id: 4 }, { text: 'TV during the week.', id: 4 },
            { text: 'Do you speak', id: 5 }, { text: 'French?', id: 5 },
            { text: 'Does your brother live', id: 6 }, { text: 'in Rio de Janeiro?', id: 6 },
            { text: 'She is working', id: 7 }, { text: 'on an important project right now.', id: 7 },
            { text: 'They are playing', id: 8 }, { text: 'soccer at this moment.', id: 8 },
            { text: "He isn't listening", id: 9 }, { text: 'to music.', id: 9 },
            { text: "We aren't watching", id: 10 }, { text: 'a movie tonight.', id: 10 },
            { text: 'Are you studying', id: 11 }, { text: 'for the test?', id: 11 },
            { text: 'Is your brother traveling', id: 12 }, { text: 'this month?', id: 12 }
        ];

        let gameMode = null; 
        let firstCard = null, secondCard = null;
        let lockBoard = false;
        let currentPlayer = 1;
        let scores = { player1: 0, player2: 0 };
        let moves = 0;
        let matchedPairs = 0;
        let gameTimeout = null;
        let peekUsedThisGame = false;

        // --- CORRIGIDO: Função shuffle reintroduzida aqui ---
        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function startGame(mode) {
            gameMode = mode;
            modeSelection.style.display = 'none';
            gameContainer.style.display = 'flex';
            createBoard();
        }

        function createBoard() {
            clearTimeout(gameTimeout);
            gameBoard.innerHTML = '';
            shuffle(sentenceParts); // Esta chamada agora funciona corretamente

            matchedPairs = 0;
            resetTurn();

            peekUsedThisGame = false;
            peekButton.disabled = false;

            if (gameMode === 'single') {
                moves = 0;
                movesCounter.textContent = `Moves: ${moves}`;
                movesCounter.style.display = 'block';
                p1ScoreElem.style.display = 'none';
                p2ScoreElem.style.display = 'none';
                turnIndicator.style.display = 'none';
            } else { 
                scores = { player1: 0, player2: 0 };
                currentPlayer = 1;
                updateScoreDisplay();
                updateTurnDisplay();
                movesCounter.style.display = 'none';
                p1ScoreElem.style.display = 'block';
                p2ScoreElem.style.display = 'block';
                turnIndicator.style.display = 'block';
            }

            sentenceParts.forEach(part => {
                const card = document.createElement('button');
                card.classList.add('card');
                card.dataset.id = part.id;
                card.innerHTML = `
                    <div class="card-face card-front">?</div>
                    <div class="card-face card-back">${part.text}</div>
                `;
                card.addEventListener('click', handleCardClick);
                gameBoard.appendChild(card);
            });
        }

        function handleCardClick() {
            if (lockBoard || this === firstCard) return;
            this.classList.add('flipped');
            if (!firstCard) {
                firstCard = this;
                return;
            }
            secondCard = this;
            lockBoard = true;
            gameBoard.classList.add('locked');
            if (gameMode === 'single') {
                moves++;
                movesCounter.textContent = `Moves: ${moves}`;
            }
            checkForMatch();
        }

        function checkForMatch() {
            const isMatch = firstCard.dataset.id === secondCard.dataset.id;
            isMatch ? handleMatch() : handleNoMatch();
        }

        function handleMatch() {
            matchedPairs++;
            if (gameMode === 'two_player') {
                scores[`player${currentPlayer}`]++;
                updateScoreDisplay();
            }
            disableCards();
            checkWinCondition();
        }

        function handleNoMatch() {
            gameTimeout = setTimeout(() => {
                unflipCards();
                if (gameMode === 'two_player') {
                    switchPlayer();
                }
            }, FLIP_DELAY);
        }

        function activatePeek() {
            if (lockBoard || peekUsedThisGame) return;

            peekUsedThisGame = true;
            peekButton.disabled = true;
            lockBoard = true;
            gameBoard.classList.add('locked');

            const unMatchedCards = document.querySelectorAll('.card:not(.matched)');
            unMatchedCards.forEach(card => card.classList.add('flipped'));

            gameTimeout = setTimeout(() => {
                unMatchedCards.forEach(card => card.classList.remove('flipped'));
                lockBoard = false;
                gameBoard.classList.remove('locked');
            }, PEEK_DURATION);
        }

        function disableCards() {
            firstCard.classList.add('matched');
            secondCard.classList.add('matched');

            firstCard.removeEventListener('click', handleCardClick);
            secondCard.removeEventListener('click', handleCardClick);

            resetTurn();
        }

        function unflipCards() {
            firstCard.classList.remove('flipped');
            secondCard.classList.remove('flipped');
            resetTurn();
        }

        function resetTurn() {
            [firstCard, secondCard] = [null, null];
            lockBoard = false;
            gameBoard.classList.remove('locked');
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTurnDisplay();
        }

        function updateScoreDisplay() {
            p1ScoreElem.textContent = `Player 1: ${scores.player1}`;
            p2ScoreElem.textContent = `Player 2: ${scores.player2}`;
        }

        function updateTurnDisplay() {
            turnIndicator.textContent = `Player ${currentPlayer}'s Turn`;
            p1ScoreElem.classList.toggle('active', currentPlayer === 1);
            p2ScoreElem.classList.toggle('active', currentPlayer === 2);
        }

        function checkWinCondition() {
            if (matchedPairs === sentenceParts.length / 2) {
                gameTimeout = setTimeout(() => {
                    let finalMessage = "Game Over!\n";
                    if (gameMode === 'single') {
                        finalMessage += `You completed the game in ${moves} moves!`;
                    } else {
                        if (scores.player1 > scores.player2) {
                            finalMessage += 'Player 1 Wins!';
                        } else if (scores.player2 > scores.player1) {
                            finalMessage += 'Player 2 Wins!';
                        } else { finalMessage += "It's a Tie!"; }
                        finalMessage += `\n\nFinal Score:\nPlayer 1: ${scores.player1}\nPlayer 2: ${scores.player2}`;
                    }
                    alert(finalMessage);
                }, 500);
            }
        }

        function resetToMenu() {
            gameContainer.style.display = 'none';
            modeSelection.style.display = 'block';
            clearTimeout(gameTimeout);
        }

        singlePlayerBtn.addEventListener('click', () => startGame('single'));
        twoPlayerBtn.addEventListener('click', () => startGame('two_player'));
        resetButton.addEventListener('click', resetToMenu);
        peekButton.addEventListener('click', activatePeek);
    });
    </script>
</body>
</html>